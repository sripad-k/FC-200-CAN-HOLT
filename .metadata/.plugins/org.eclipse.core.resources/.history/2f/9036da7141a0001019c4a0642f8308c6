#include "soc/defines/d_common_types.h"
#include "soc/uart/d_uart.h"
#include "soc/timer/d_timer.h"
#include "soc/defines/d_common_status.h"
#include "soc/can/d_can_cfg.h"
#include "soc/can/d_can.h"
#include "sru/can_holt/d_can_holt.h"                  /* Discrete driver */
#include "sru/can_holt/d_can_holt_cfg.h"              /* Discrete driver config */
#include "kernel/general/d_gen_string.h"
#include "soc/discrete/d_discrete.h"
#include "ETAS_global.h"

static const Uint32_t UART_CHANNEL = 0U;
static const Uint32_t UART_BAUD = 115200U;

const static Uint32_t BIT_SET   = 0x00000001u;      /* 32 bit unsigned integer with LS bit set to 1 */
Bool_t CANInitialised[d_CAN_MAX_INTERFACES];
Bool_t CANHOLTInitialised[d_CAN_HOLT_MAX_INTERFACES];

d_CAN_Message_t rxMessage;
d_CAN_Message_t tx1Message = {d_TRUE, 0x290, 0x0080, d_TRUE, d_FALSE, 8, {0xFC, 0xC1, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_Message_t tx2Message = {d_TRUE, 0x290, 0x0081, d_TRUE, d_FALSE, 8, {0xFC, 0xC2, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_HOLT_Message_t tx3Message = {d_TRUE, 0x290, 0x0082, d_TRUE, d_FALSE, 8, {0xFC, 0xC3, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_HOLT_Message_t tx4Message = {d_TRUE, 0x290, 0x0083, d_TRUE, d_FALSE, 8, {0xFC, 0xC4, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_HOLT_Message_t tx5Message = {d_TRUE, 0x290, 0x0084, d_TRUE, d_FALSE, 8, {0xFC, 0xC5, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};

static d_Status_t uart_init(void);
static d_Status_t can_init(void);

Int32_t main()
{
	d_Status_t uart_init_status = d_STATUS_SUCCESS;
	d_Status_t can_init_status = d_STATUS_SUCCESS;

	d_TIMER_Initialise();
	uart_init_status = uart_init();
	can_init_status = can_init();

	if((uart_init_status == d_STATUS_SUCCESS) && (can_init_status == d_STATUS_SUCCESS))
	{
		GLOBAL_SerialPrint_Simple(" Reading Discrete on the SoC of FC-200.\n\r");

		/* Debug */
		while(1)
		{

			d_CAN_SendMessage(0, &tx1Message);

			d_CAN_SendMessage(1, &tx2Message);

			d_CAN_HOLT_SendMessage(0, &tx3Message);

			d_CAN_HOLT_SendMessage(1, &tx4Message);

			d_CAN_HOLT_SendMessage(2, &tx5Message);

			d_TIMER_DelayMilliseconds(100);


		}
	}

}

static d_Status_t uart_init(void)
{

	d_Status_t retVal = d_STATUS_SUCCESS;

	/* Initialize UART 0 */
	retVal = d_UART_Configure(UART_CHANNEL, UART_BAUD, d_UART_DATA_BITS_8, d_UART_PARITY_NONE, d_UART_STOP_BITS_1);

	return retVal;
}

static d_Status_t                                  /** \return d_STATUS_SUCCESS if the operation was successful */
can_init
(
	void                                      /** NONE */
)
{
	  d_Status_t setupValue = d_STATUS_SUCCESS;

	  // Initialise the PS CAN interfaces.
	  for(Uint8_t i=0; i<d_CAN_MAX_INTERFACES; i++)
	  {
	    setupValue = d_CAN_Initialise(i);

	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      setupValue = d_CAN_ModeSet(i, d_CAN_MODE_NORMAL);
	    }
	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      CANInitialised[i] = d_TRUE;
	    }
	    else
	    {
	      CANInitialised[i] = d_FALSE;
	    }
	  }  // End FOR each PS CAN interface.

	  // Initialise the HOLT CAN interfaces.
	  for(Uint8_t i=0; i<3; i++)   // d_CAN_HOLT_COUNT should have the correct number based on d_can_holt_cfg, but the build fails when trying to use this constant here.
	  {
	    setupValue = d_CAN_HOLT_Initialise(i);

	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      setupValue = d_CAN_HOLT_FilterDisable(i);
	    }
	    if(setupValue == d_STATUS_SUCCESS)
	    {
	        setupValue = d_CAN_HOLT_ModeSet(i, d_CAN_HOLT_MODE_NORMAL);
	    }
	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      CANHOLTInitialised[i] = d_TRUE;
	    }
	    else
	    {
	      CANHOLTInitialised[i] = d_FALSE;
	    }
	  }  // End FOR each HOLT CAN interface

	return (d_STATUS_SUCCESS);  // This is currently just returning success. On startup each individual interface can pass/fail depending on availability.
}
