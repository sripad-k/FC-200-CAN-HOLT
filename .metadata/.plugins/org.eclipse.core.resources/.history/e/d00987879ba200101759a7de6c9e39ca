#include "soc/defines/d_common_types.h"
#include "soc/uart/d_uart.h"
#include "soc/timer/d_timer.h"
#include "soc/defines/d_common_status.h"
#include "soc/can/d_can_cfg.h"
#include "soc/can/d_can.h"
#include "sru/can_holt/d_can_holt.h"                  /* Discrete driver */
#include "sru/can_holt/d_can_holt_cfg.h"              /* Discrete driver config */
#include "kernel/general/d_gen_string.h"
#include "soc/discrete/d_discrete.h"
#include "ETAS_global.h"

#define MAX_CAN_INTERFACE (2)
#define MAX_CAN_HOLT_INTERFACE (3)

static const Uint32_t UART_CHANNEL = 0U;
static const Uint32_t UART_BAUD = 115200U;


Bool_t CANInitialised[MAX_CAN_INTERFACE];
Bool_t CANHOLTInitialised[MAX_CAN_HOLT_INTERFACE];

d_CAN_Message_t rx1Message = {d_TRUE, 0x290, 0x0041, d_TRUE, d_FALSE, 8, {0xFC, 0xC1, 0, 0, 0, 0, 0, 0}};
d_CAN_Message_t rx2Message = {d_TRUE, 0x290, 0x0042, d_TRUE, d_FALSE, 8, {0xFC, 0xC2, 0, 0, 0, 0, 0, 0}};

d_CAN_HOLT_Filter_t mask = {d_TRUE, 0x7FF, 0x3FFFF, {0x00, 0x00}};
d_CAN_HOLT_Filter_t filter1 = {d_TRUE, 0x290, 0x0043, {0x00, 0x00}};
d_CAN_HOLT_Filter_t filter2 = {d_TRUE, 0x290, 0x0044, {0x00, 0x00}};
d_CAN_HOLT_Filter_t filter3 = {d_TRUE, 0x290, 0x0045, {0x00, 0x00}};

d_CAN_HOLT_Message_t rx3Message ;//= {d_TRUE, 0x290, 0x0043, d_TRUE, d_FALSE, 8, {0xFC, 0xC3, 0, 0, 0, 0, 0, 0}};
d_CAN_HOLT_Message_t rx4Message ;//= {d_TRUE, 0x290, 0x0044, d_TRUE, d_FALSE, 8, {0xFC, 0xC4, 0, 0, 0, 0, 0, 0}};
d_CAN_HOLT_Message_t rx5Message ;//= {d_TRUE, 0x290, 0x0045, d_TRUE, d_FALSE, 8, {0xFC, 0xC5, 0, 0, 0, 0, 0, 0}};

d_CAN_Message_t tx1Message = {d_TRUE, 0x290, 0x0081, d_TRUE, d_FALSE, 8, {0xFC, 0xC1, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_Message_t tx2Message = {d_TRUE, 0x290, 0x0082, d_TRUE, d_FALSE, 8, {0xFC, 0xC2, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_HOLT_Message_t tx3Message = {d_TRUE, 0x290, 0x0083, d_TRUE, d_FALSE, 8, {0xFC, 0xC3, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_HOLT_Message_t tx4Message = {d_TRUE, 0x290, 0x0084, d_TRUE, d_FALSE, 8, {0xFC, 0xC4, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};
d_CAN_HOLT_Message_t tx5Message = {d_TRUE, 0x290, 0x0085, d_TRUE, d_FALSE, 8, {0xFC, 0xC5, 0xDF, 0xCC, 0xCA, 0xFE, 0xBA, 0xBE}};


static d_Status_t uart_init(void);
static d_Status_t can_init(void);
static void CAN_ReadMsg ( void );
static void CAN_ReadHoltMsg ( void );

Int32_t main()
{
	d_Status_t uart_init_status = d_STATUS_SUCCESS;
	d_Status_t can_init_status = d_STATUS_SUCCESS;

	// d_Status_t Msg_received = d_STATUS_NO_DATA;

	d_TIMER_Initialise();
	uart_init_status = uart_init();
	can_init_status = can_init();

	if((uart_init_status == d_STATUS_SUCCESS) && (can_init_status == d_STATUS_SUCCESS))
	{
		GLOBAL_SerialPrint_Simple(" CAN TX and RX on FC-200.\n\r");

		/* Debug */
		while(1)
		{

			d_CAN_SendMessage(0, &tx1Message);

			d_CAN_SendMessage(1, &tx2Message);

			d_CAN_HOLT_SendMessage(0, &tx3Message);

			d_CAN_HOLT_SendMessage(1, &tx4Message);

			d_CAN_HOLT_SendMessage(2, &tx5Message);

			d_TIMER_DelayMilliseconds(100);

	        /* Receive CAN message */
			CAN_ReadMsg();
			CAN_ReadHoltMsg();

		}
	}

}

static d_Status_t uart_init(void)
{

	d_Status_t retVal = d_STATUS_SUCCESS;

	/* Initialize UART 0 */
	retVal = d_UART_Configure(UART_CHANNEL, UART_BAUD, d_UART_DATA_BITS_8, d_UART_PARITY_NONE, d_UART_STOP_BITS_1);

	return retVal;
}

static d_Status_t                                  /** \return d_STATUS_SUCCESS if the operation was successful */
can_init
(
	void                                      /** NONE */
)
{
	  d_Status_t setupValue = d_STATUS_SUCCESS;
	  d_CAN_HOLT_Filter_t setfilter;
	  d_CAN_HOLT_Filter_t setmask;

	  // Initialise the PS CAN interfaces.
	  for(Uint8_t i=0; i<d_CAN_MAX_INTERFACES; i++)
	  {
	    setupValue = d_CAN_Initialise(i);

	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      setupValue = d_CAN_ModeSet(i, d_CAN_MODE_NORMAL);
	    }
	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      CANInitialised[i] = d_TRUE;
	    }
	    else
	    {
	      CANInitialised[i] = d_FALSE;
	    }
	  }  // End FOR each PS CAN interface.


	  /* Program CAN Filtering on a single ID or a range of IDs */
	  d_CAN_ProgramCanIdFilter(0, d_TRUE, &rx1Message, NULL);

	  d_CAN_ProgramCanIdFilter(1, d_TRUE, &rx2Message, NULL);

	  // Initialise the HOLT CAN interfaces.
	  for(Uint8_t i=0; i<MAX_CAN_HOLT_INTERFACE; i++)   // d_CAN_HOLT_COUNT should have the correct number based on d_can_holt_cfg, but the build fails when trying to use this constant here.
	  {
	    setupValue = d_CAN_HOLT_Initialise(i);

	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      setupValue = d_CAN_HOLT_FilterDisable(i);
	    }
	    if(setupValue == d_STATUS_SUCCESS)
	    {
	        setupValue = d_CAN_HOLT_ModeSet(i, d_CAN_HOLT_MODE_NORMAL);
	    }
	    if(setupValue == d_STATUS_SUCCESS)
	    {
	      CANHOLTInitialised[i] = d_TRUE;
	    }
	    else
	    {
	      CANHOLTInitialised[i] = d_FALSE;
	    }
	  }  // End FOR each HOLT CAN interface

	  /* Disable all the filters */
	  d_CAN_HOLT_FilterDisable(0);
	  d_CAN_HOLT_FilterDisable(1);
	  d_CAN_HOLT_FilterDisable(2);


	  /* Set filter and mask for channel-0, 1 & 2 */
	  d_CAN_HOLT_FilterSet(0, 0, &filter1, &mask);

	  d_CAN_HOLT_FilterSet(1, 0, &filter2, &mask);

	  d_CAN_HOLT_FilterSet(2, 0, &filter3, &mask);


	  /* Wait for SPI TX and device to sync with updated register configuration before responding */
	  d_TIMER_DelayMilliseconds(50);

	  /* Read back Filter Configuration of CAN Holt channel-0, 1 & 2 */
	  d_CAN_HOLT_FilterGet(0, 0, &setfilter, &setmask);
	  /* Compare contents of setfilter and filter1 */
	  if((setfilter.exId == filter1.exId) &&
	     (setfilter.id == filter1.id) &&
		 (setfilter.extended == filter1.extended))
	  {
		  GLOBAL_SerialPrint_Simple("   Filter 1 set correctly\n\r");
	  }
	  else
	  {
		  GLOBAL_SerialPrint_Simple("   Filter 1 set incorrectly\n\r");
	  }

	  /* Compare contents of setmask and mask */
	  if((setmask.exId ==  mask.exId) && (setmask.id == mask.id))
	  {
		  GLOBAL_SerialPrint_Simple("   Mask 1 set correctly\n\r");
	  }
	  else
	  {
		  GLOBAL_SerialPrint_Simple("   Mask 1 set incorrectly\n\r");
	  }


	  d_CAN_HOLT_FilterGet(1, 0, &setfilter, &setmask);
	  /* Compare contents of setfilter and filter2 */
	  /* Compare contents of setfilter and filter1 */
	  if((setfilter.exId == filter2.exId) &&
	     (setfilter.id == filter2.id) &&
		 (setfilter.extended == filter2.extended))
	  {
		  GLOBAL_SerialPrint_Simple("   Filter 2 set correctly\n\r");
	  }
	  else
	  {
		  GLOBAL_SerialPrint_Simple("   Filter 2 set incorrectly\n\r");
	  }

	  /* Compare contents of setmask and mask */
	  if((setmask.exId ==  mask.exId) && (setmask.id == mask.id))
	  {
		  GLOBAL_SerialPrint_Simple("   Mask 2 set correctly\n\r");
	  }
	  else
	  {
		  GLOBAL_SerialPrint_Simple("   Mask 2 set incorrectly\n\r");
	  }


	  d_CAN_HOLT_FilterGet(2, 0, &setfilter, &setmask);
	  /* Compare contents of setfilter and filter3 */
	  /* Compare contents of setfilter and filter1 */
	  if((setfilter.exId == filter3.exId) &&
	     (setfilter.id == filter3.id) &&
		 (setfilter.extended == filter3.extended))
	  {
		  GLOBAL_SerialPrint_Simple("   Filter 3 set correctly\n\r");
	  }
	  else
	  {
		  GLOBAL_SerialPrint_Simple("   Filter 3 set incorrectly\n\r");
	  }

	  /* Compare contents of setmask and mask */
	  if((setmask.exId ==  mask.exId) && (setmask.id == mask.id))
	  {
		  GLOBAL_SerialPrint_Simple("   Mask 3 set correctly\n\r");
	  }
	  else
	  {
		  GLOBAL_SerialPrint_Simple("   Mask 3 set incorrectly\n\r");
	  }

	  d_CAN_HOLT_FilterEnable(0);
	  d_CAN_HOLT_FilterEnable(1);
	  d_CAN_HOLT_FilterEnable(2);


	return (d_STATUS_SUCCESS);  // This is currently just returning success. On startup each individual interface can pass/fail depending on availability.
}


static void CAN_ReadMsg ( void )
{
  // For all the interfaces, not just IF 0
  for(Uint8_t canIndex=0; canIndex<d_CAN_MAX_INTERFACES; canIndex++)
  {
    if(CANInitialised[canIndex] == d_TRUE)
    {
      d_CAN_Message_t inMsg;
      d_Status_t receiveSuccess = d_STATUS_SUCCESS;
      Uint8_t msgCounter = 0;   // Debug value just used to see multiple messages can be processed in a single cycle.
      while (receiveSuccess == d_STATUS_SUCCESS)
      {
        receiveSuccess = d_CAN_ReceiveMessage(canIndex, &inMsg);

        Uint32_t can_rx_id = ((inMsg.id << 18) | (inMsg.exId));

        if(receiveSuccess == d_STATUS_SUCCESS)
        {
          msgCounter++;
//          GLOBAL_SerialPrint("   CAN Rx OK: (Msg counter: %d), (IF:%f)\n\r",msgCounter,canIndex);
          GLOBAL_SerialPrint("  CAN ID = %x\r\n", can_rx_id, 0.0f);
          for(Uint8_t i=0; i<inMsg.dataLength; i++)
          {
           GLOBAL_SerialPrint("   Data: %x Byte: %f\n\r",inMsg.data[i],i);
          }
        }
        else if (receiveSuccess == d_STATUS_NO_DATA)
        {
          //Normal end of data after all messages read, OR no data available.
//          GLOBAL_SerialPrint("   CAN Rx - No more data\n\r",receiveSuccess,0.0f);
        }
        else
        {
          GLOBAL_SerialPrint("   CAN Rx FAIL %d\n\r",receiveSuccess,0.0f);
        }
      }
    }
  }
}

static void CAN_ReadHoltMsg ( void )
{
  // For all the interfaces, not just IF 0
  for(Uint8_t canIndex=0; canIndex<MAX_CAN_HOLT_INTERFACE; canIndex++)
  {
    if(CANHOLTInitialised[canIndex] == d_TRUE)
    {
      d_CAN_Message_t inMsg;
      d_Status_t receiveSuccess = d_STATUS_SUCCESS;
      Uint8_t msgCounter = 0;   // Debug value just used to see multiple messages can be processed in a single cycle.
      while (receiveSuccess == d_STATUS_SUCCESS)
      {
        receiveSuccess = d_CAN_HOLT_ReceiveMessage(canIndex, &inMsg);

        Uint32_t can_rx_id = ((inMsg.id << 18) | (inMsg.exId));

        if(receiveSuccess == d_STATUS_SUCCESS)
        {
          msgCounter++;
//          GLOBAL_SerialPrint("   CAN Rx OK: (Msg counter: %d), (IF:%f)\n\r",msgCounter,canIndex);
          GLOBAL_SerialPrint("  CAN ID = %x\r\n", can_rx_id, 0.0f);
          for(Uint8_t i=0; i<inMsg.dataLength; i++)
          {
           GLOBAL_SerialPrint("   Data: %x Byte: %f\n\r",inMsg.data[i],i);
          }
        }
        else if (receiveSuccess == d_STATUS_NO_DATA)
        {
          //Normal end of data after all messages read, OR no data available.
//          GLOBAL_SerialPrint("   CAN Rx - No more data\n\r",receiveSuccess,0.0f);
        }
        else
        {
          GLOBAL_SerialPrint("   CAN Rx FAIL %d\n\r",receiveSuccess,0.0f);
        }
      }
    }
  }
}



